"""A module to handle missing sensor data from the sensor nodes.

For each sensor node we maintain a structure containing the indexes of incoming data.
These ids are generated by the
sensor node in ascending order starting from one.

The sensor node has a circular buffer where it stores data.
This buffer is stored in memory, thus is wiped out when the sensor node power up.
The sensor node reads message every one second.
"""

import os.path
import threading

import paho.mqtt.client
import pickle
from typing import List, Dict

import log

SENSOR_NODE_CIRCULAR_BUFFER_SIZE = 3600
"""
The sensor node has a circular buffer where it stores messages sent to the MQTT server.
"""

SENSOR_NODE_INITIAL_MESSAGE_INDEX = 1
"""
When the sensor node boots, the first message index has this value.
"""

sync = threading.Semaphore ()
"""
Semaphore to synchronise updates to sensor data message intervals.
This structure is updated whenever a new message is received and is
saved periodically when we check for missing data.
"""

requesting_missing_data = False  # type: bool

MISSING_DATA_LOG_FILE = '/var/log/expolis/missing-data.log'


class Interval:
    def __init__ (self, idx: int):
        self.start = idx
        self.end = idx

    def __repr__(self):
        return '{}-{}'.format (self.start, self.end)


class SensorData:
    def __init__(self, sensor_id: int):
        self.sensor_id = sensor_id
        self.message_intervals = []  # type: List[Interval]
        self.newest_message_timestamp = 0  # type: float

    def add_message_info (self, message_index: int, message_timestamp: float):
        sync.acquire ()
        if self.newest_message_timestamp < message_timestamp:
            if self.__has_sensor_node_rebooted (message_index):
                self.message_intervals = [Interval (message_index)]
            else:
                self.__update_message_intervals (message_index)
                self.__remove_old_message_intervals (message_index)
        else:
            self.__update_message_intervals (message_index)
        self.newest_message_timestamp = message_timestamp
        sync.release ()

    def __update_message_intervals (self, message_index):
        """
        Update the message index intervals.
        """
        if not self.message_intervals:
            self.message_intervals = [Interval (message_index)]
        elif self.message_intervals [0].start - 1 == message_index:
            self.message_intervals [0].start += -1
        elif self.message_intervals [0].start > message_index:
            self.message_intervals.insert (0, Interval (message_index))
        elif self.message_intervals [-1].end + 1 == message_index:
            self.message_intervals [-1].end += 1
        elif self.message_intervals [-1].end < message_index:
            self.message_intervals.append (Interval (message_index))
        else:
            idx = 1
            while idx < len (self.message_intervals):
                g1 = self.message_intervals [idx - 1]
                g2 = self.message_intervals [idx]
                if g1.end < message_index < g2.start:
                    if g1.end + 1 == message_index:
                        if g2.start - 1 == message_index:
                            g1.end = g2.end
                            del self.message_intervals [idx]
                        else:
                            g1.end += 1
                    elif g2.start - 1 == message_index:
                        g2.start += -1
                    else:
                        gn = Interval (message_index)
                        self.message_intervals.insert (idx, gn)
                    break
                else:
                    idx += 1

    def __has_sensor_node_rebooted (self, message_index) -> bool:
        """
        A message with the newest timestamp has arrived and we have to
        check if the sensor node has rebooted.  Either a message with
        the initial message index has been sent, or the docker
        database has been launched after the sensor node has rebooted.
        """
        return message_index == SENSOR_NODE_INITIAL_MESSAGE_INDEX

    def __remove_old_message_intervals (self, message_index: int) -> None:
        """
        A message with the newest timestamp has arrived and we have to
        remove and update message intervals that are not available in
        the sensor node.
        """
        oldest_available_message_index = max (
            SENSOR_NODE_INITIAL_MESSAGE_INDEX,
            message_index - SENSOR_NODE_CIRCULAR_BUFFER_SIZE)
        while self.message_intervals [0].start < oldest_available_message_index:
            if self.message_intervals [0].end < oldest_available_message_index:
                self.message_intervals = self.message_intervals [1:]
            else:
                self.message_intervals [0].start = oldest_available_message_index

    def manage_intervals (self):
        sync.acquire ()
        n = len (self.message_intervals)
        i = 0
        while i < n:
            answer = input ('Keep / Edit / Delete interval {}? '.format (self.message_intervals [i]))
            answer = answer.upper ()
            if answer == 'K':
                i += 1
            elif answer == 'E':
                ok = False
                while not ok:
                    try:
                        self.message_intervals [i].start = int (input ('Start? '))
                        self.message_intervals [i].end = int (input ('End? '))
                        ok = self.message_intervals [i].start <= self.message_intervals [i].end
                        if not ok:
                            print ('Enter a valid range')
                    except ValueError:
                        print ('Enter a valid number')
                i += 1
            elif answer == 'D':
                del self.message_intervals [i:(i+1)]
                n = n - 1
            else:
                print ('Please enter one of K, E or D.')
        sync.release ()

    def request_missing_data (self, sensor_id: int, mqtt_client: paho.mqtt.client.Client):
        if len (self.message_intervals) < 2:
            return
        sync.acquire ()
        request = 'RESEND'
        index = 1
        while index < len (self.message_intervals):
            interval1 = self.message_intervals [index - 1]
            interval2 = self.message_intervals [index]
            request += ' {}-{}'.format (interval1.end + 1, interval2.start - 1)
            index += 1
        sync.release ()
        mqtt_client.publish (
            topic=self.mqtt_sensor_node_management_topic (),
            payload=request
        )
        with open (MISSING_DATA_LOG_FILE, 'a') as fd:
            log.log (fd, 'Requested for sensor {} missing data {}'.format (sensor_id, self))

    def mqtt_sensor_node_management_topic (self):
        return 'expolis_project/sensor_nodes/managment/sn_{}'.format (self.sensor_id)

    def __str__(self):
        return '{} {}'.format (self.newest_message_timestamp, self.message_intervals)


message_intervals = {}  # type: Dict[int, SensorData]
FILENAME = '/var/lib/expolis/message_intervals'


def add_message_info (
        sensor_id: int,
        message_index: int,
        message_timestamp: float
):
    # global message_intervals
    if sensor_id not in message_intervals:
        message_intervals [sensor_id] = SensorData (sensor_id)
    message_intervals [sensor_id].add_message_info (message_index, message_timestamp)


def reset_intervals ():
    global message_intervals
    message_intervals = {
        sensor_id: SensorData (sensor_id)
        for sensor_id in message_intervals
    }
    save_message_intervals ()


def load_message_intervals ():
    global message_intervals
    if os.path.exists (FILENAME):
        with open (FILENAME, 'rb') as fd:
            message_intervals = pickle.load (fd)
        # upgrade
        if len (message_intervals) > 0:
            try:
                for sensor_id in message_intervals:
                    message_intervals [sensor_id].__getattribute__ ('newest_message_timestamp')
            except AttributeError:
                for sensor_id in message_intervals:
                    message_intervals [sensor_id].newest_message_timestamp = 0
            try:
                for sensor_id in message_intervals:
                    message_intervals [sensor_id].__getattribute__ ('sensor_id')
            except AttributeError:
                for sensor_id in message_intervals:
                    message_intervals [sensor_id].sensor_id = sensor_id


def save_message_intervals ():
    sync.acquire ()
    with open (FILENAME, 'wb') as fd:
        pickle.dump (message_intervals, fd)
    sync.release ()


def request_missing_data (mqtt_client: paho.mqtt.client.Client):
    """
    Function called by the Timer created at start_request_missing_data_timer
    :param mqtt_client:
    :return:
    """
    save_message_intervals ()
    if not requesting_missing_data:
        return
    for sensor_id in message_intervals:
        message_intervals [sensor_id].request_missing_data (sensor_id, mqtt_client)
    __start_request_missing_data_timer (mqtt_client)


def start_request_missing_data_timer (mqtt_client: paho.mqtt.client.Client):
    global requesting_missing_data
    requesting_missing_data = True
    __start_request_missing_data_timer (mqtt_client)


def __start_request_missing_data_timer (mqtt_client: paho.mqtt.client.Client):
    t = threading.Timer (
        interval=60,
        function=request_missing_data,
        args=(mqtt_client, )
    )
    t.start ()


def stop_requesting_data ():
    global requesting_missing_data
    requesting_missing_data = False


def setup ():
    load_message_intervals ()


setup ()
